<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Web Showcase with Animated Nav</title>
    <style>
        /* 1. CSS 변수 및 기본 페이지 설정 (쇼케이스 기준) */
        :root {
            --bg-color: #101726; /* [수정] 네이비 색상으로 변경 */
            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --card-width: 676px; /* 520px * 1.3 */
            --card-height: 435px; /* 335px * 1.3 */
            --card-width: 811px; /* 676px * 1.2 */
            --card-height: 522px; /* 435px * 1.2 */
            --stack-perspective: 2000px;
            --animation-duration: 1.2s;
            --animation-ease: cubic-bezier(0.22, 1, 0.36, 1);
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            /* --- [수정] 높이를 1080px로 고정하고 중앙 정렬 --- */
            /* [수정] 2분할 레이아웃을 위해 body를 flex 컨테이너로 사용 */
            display: flex;
            height: 100vh; /* 전체 화면 높이 사용 */
            margin: 0;
        }

        /* --- [추가된 부분] 메뉴 바를 위한 Header 스타일 --- */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000; /* 카드 스택보다 위에 오도록 설정 */
            display: flex;
            justify-content: center;
            padding: 2rem 0;
            pointer-events: none; /* 헤더 영역은 클릭 방해 안 함 */
        }

        /* --- 메뉴 바 스타일 시작 --- */
        .nav-container {
            pointer-events: auto; /* 메뉴 바 자체는 클릭 가능하도록 설정 */
            display: flex;
            align-items: center;
            gap: 40px;
            background: rgba(255, 255, 255, 0.12);
            padding: 14px 32px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: 0.3s ease;
        }

        .logo {
            width: 60px;
            height: 40px;
        }

        .menu {
            display: flex;
            gap: 32px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
        }

        .menu-item {
            position: relative;
            cursor: pointer;
            height: 30px;
            line-height: 30px;
            overflow: hidden;
        }

        .word-shifter {
            transition: transform 0.6s cubic-bezier(0.76, 0, 0.24, 1);
        }
        
        .menu-item.is-animating .word-shifter {
            transform: translateY(-30px);
        }

        .visible-word, .hidden-word {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 30px;
            white-space: nowrap;
        }

        .circle-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: 0.3s;
        }

        .circle-btn:hover { background: rgba(255,255,255,0.2); }
        .nav-container:hover { transform: scale(1.03); }
        /* --- 메뉴 바 스타일 끝 --- */


        /* --- 쇼케이스 스타일 시작 --- */
        .showcase-text {
            /* [수정] 왼쪽 영역 스타일 */
            width: 50vw;
            padding-left: 200px; /* [수정] 왼쪽으로부터 200px 여백 */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .showcase-text h1 { font-size: 3.5rem; line-height: 1.15; margin-bottom: 1.5rem; font-weight: 800; letter-spacing: -0.05em; }
        /* [추가] h2 태그에 대한 스타일 정의 */
        .showcase-text h2 {
            font-size: 2.5rem; /* h1과 균형을 맞추도록 크기 조정 */
            font-weight: 600;
            margin: -1rem 0 2rem 0; /* 불필요한 여백 제거 및 조정 */
            letter-spacing: -0.05em;
        }
        .showcase-text p { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; max-width: 730px; /* [수정] 가로 길이를 560px로 늘림 */ }

        .website-stack-container {
            /* [수정] 오른쪽 영역 스타일 */
            width: 50vw;
            padding-right: 100px; /* [추가] 오른쪽으로부터 100px 여백 */
            align-items: center;
            height: calc(var(--card-height) + 150px);
            position: relative;
            perspective: var(--stack-perspective);
            display: flex;
            cursor: pointer; /* 클릭 가능함을 나타내기 위해 커서 변경 */
            justify-content: center;
            align-items: center;
            height: 100vh; /* 오른쪽 영역 전체 높이 사용 */
            overflow: hidden; /* 내부 애니메이션이 영역을 벗어나지 않도록 설정 */
        }
        
        /* --- [추가] 카드 포커스 시 컨테이너가 카드를 가리지 않도록 설정 --- */
        .website-stack-container.has-focused {
            overflow: visible; /* 포커스된 카드가 컨테이너 밖으로 나갈 수 있도록 허용 */
            z-index: 150; /* 왼쪽 텍스트 영역보다 위에 오도록 설정 */
            position: relative; /* z-index 적용을 위해 position 설정 */
        }

        .website-card {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            border-radius: 18px;
            overflow: hidden;
            background: rgba(28, 26, 38, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(25px);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.3);
            transform-origin: 100% 50%; /* [수정] 애니메이션 기준점을 오른쪽 중앙으로 변경 */
            transition: transform var(--animation-duration) var(--animation-ease), opacity calc(var(--animation-duration) / 2) ease;
            transform-style: preserve-3d;
            will-change: transform, opacity;
        }

        /* --- [추가] 펼쳐진 카드에 대한 호버 효과 --- */
        .website-stack-container.is-fanned .website-card:hover {
            /* [수정] 크기 변경(transform) 효과 제거 */
            filter: brightness(1.2); /* 카드를 더 밝게 */
            z-index: 100 !important; /* 호버된 카드를 맨 위로 */
            transition: filter 0.4s, z-index 0.4s; /* [수정] 필터와 z-index 전환만 남김 */
        }

        /* --- [추가] 클릭 시 상세보기를 위한 포커스 스타일 --- */
        .website-stack-container.is-fanned .website-card.is-focused {
            /* 정면을 보도록 회전하고, 앞으로 당기며, 1.4배 확대 */
            transform: translateZ(300px) rotateY(0deg) scale(1.4) !important;
            opacity: 1 !important;
            z-index: 200 !important; /* 다른 모든 요소를 덮도록 z-index 최대로 설정 */
            cursor: zoom-out; /* 축소 가능함을 나타내는 커서 */
            filter: brightness(1); /* 호버 효과 덮어쓰기 */
        }

        /* --- [추가] 포커스 상태일 때 내부 이미지도 함께 커지도록 설정 --- */
        .website-card.is-focused .card-image {
            object-fit: cover; /* 기본적으로 이미지가 카드를 꽉 채우도록 설정 */
        }
        .website-card.is-focused .card-image[alt="Profile Character"] {
            object-fit: contain; /* 프로필 캐릭터 이미지는 잘리지 않도록 contain 유지 */
        }

        /* --- [추가] 포커스 상태일 때 다른 카드들은 흐리게 처리 --- */
        .website-stack-container.is-fanned.has-focused .website-card:not(.is-focused) {
            filter: blur(5px) brightness(0.5);
            transform: scale(0.95); /* 약간 작게 만들어 집중도 향상 */
        }

        /* --- [추가] 펼쳐진 상태에서 중앙에 위치한 카드 강조 스타일 --- */
        .website-stack-container.is-fanned .website-card.is-center {
            z-index: 100 !important; /* 다른 카드보다 위에 오도록 설정 */
            /* [수정] 중앙에 있다고 바로 밝아지지 않도록 filter 제거 */
        }
        /* [추가] 중앙에 위치한 카드에 호버했을 때만 밝아지도록 수정 */
        .website-stack-container.is-fanned .website-card.is-center:hover {
            z-index: 101 !important;
            filter: brightness(1.15);
        }



        .card-header { display: flex; align-items: center; padding: 0.75rem; background: rgba(0, 0, 0, 0.25); }
        .window-dots { display: flex; gap: 0.5rem; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        .dot-red { background: #ff5f56; }
        .dot-yellow { background: #ffbd2e; }
        .dot-green { background: #27c93f; }

        .card-body { width: 100%; height: calc(100% - 38px); }
        .card-image { width: 100%; height: 100%; object-fit: cover; object-position: top center; }

        /* 반응형 디자인 */
        @media (max-width: 1100px) {
            body { flex-direction: column; text-align: center; }
            .showcase-text p { margin: 0 auto; }
        }
        @media (max-width: 600px) {
            :root { --card-width: 90vw; --card-height: 58vw; }
            .showcase-text h1 { font-size: 2.5rem; }
            .showcase-text p { font-size: 1.1rem; }
        }
        /* --- 쇼케이스 스타일 끝 --- */

        /* --- [추가] 카드 내부 콘텐츠 스타일 --- */
        .card-link {
            display: block;
            width: 100%;
            height: 100%;
            /* --- [수정] 기본적으로 링크 클릭 비활성화 --- */
            pointer-events: none;
            text-decoration: none;
            color: inherit;
        }
        /* --- [추가] 카드가 펼쳐졌을 때만 링크 클릭 활성화 --- */
        .website-stack-container.is-fanned .card-link {
            pointer-events: auto;
        }
        .card-content {
            padding: 20px;
        }
        .card-footer-text {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
        }

    </style>
</head>
<body>

    <!-- [추가] 스파클 배경 효과를 위한 Canvas -->
    <canvas id="sparkle-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none;"></canvas>

    <!-- [추가] 메뉴 바 HTML -->
    <header>
        <div class="nav-container">
            <a href="index.html"><img src="img/logo.png" alt="Logo" class="logo"></a>
            <div class="menu">
                <div class="menu-item" id="menu-welcome">
                    <div class="word-shifter">
                        <div class="visible-word">WELCOME</div>
                        <div class="hidden-word"></div>
                    </div>
                </div>
                <div class="menu-item" id="menu-project">
                    <div class="word-shifter">
                        <div class="visible-word">PROJECT</div>
                        <div class="hidden-word"></div>
                    </div>
                </div>
                <div class="menu-item" id="menu-contact">
                    <a href="contact.html" style="text-decoration: none; color: inherit;">
                        <div class="word-shifter">
                            <div class="visible-word">CONTACT</div>
                            <div class="hidden-word"></div>
                        </div>
                    </a>
                </div>
            </div>
            <div class="circle-btn">≡</div>
        </div>
    </header>

    <!-- 기존 쇼케이스 HTML --> 
    <!-- [수정] 2분할 레이아웃을 위해 showcase-container 제거 -->
    <div class="showcase-text">
        <h1>“ Product designer ”</h1>
        <h2> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 디지털 기반의 서비스를 디자인하고, <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 포괄적 관점에서 사용자의 경험을 설계합니다. </h2>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;저의 디자인은 '새로움'으로 시선을 끌고, '어울림'으로 마음을 붙잡습니다. 
            <br>
            <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;혁신은 언제나 낯설지만, 그 경험은 반드시 직관적이어야 합니다. 
            <br>
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모두가 새로움을 만나는 어떠한 접점에서든 망설임 없이 다음 단계로 나아갈 수 있도록 
            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;어울리게, 그 모든 과정을 치밀하게 설계합니다.
                가장 대담한 시도가 가장 편안한 경험이 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 되도록 하는 디자이너가 되도록, 끊임없이 노력하겠습니다.</p>
    </div>
    <div class="website-stack-container">
        <div class="website-card">
            <div class="card-header"><div class="window-dots"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span></div></div>
            <!-- [수정] 1번 카드 이미지 경로 오류 수정 -->
            <div class="card-body"><img class="card-image" src="img/HM2.png" alt="Profile Character" style="object-fit: contain;"></div>
            <div class="card-footer-text"> hye min <br> profile</div>
        </div>
        <div class="website-card">
            <div class="card-header"><div class="window-dots"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span></div></div>
            <div class="card-body"><img class="card-image" src="img/dblunchar.png" alt="Abstract design 2"></div>
            <div class="card-footer-text">UI UX <br> Dict Box redesign
            </div>
        </div>
        <div class="website-card">
            <div class="card-header"><div class="window-dots"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span></div></div>
            <div class="card-body"><img class="card-image" src="img/poster2.png" alt="Abstract design 3"></div>
            <div class="card-footer-text">steck 3</div>
        </div>
        <div class="website-card">
            <div class="card-header"><div class="window-dots"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span></div></div>
            <div class="card-body"><img class="card-image" src="img/betterdaym.png" alt="Abstract design 4"></div>
            <div class="card-footer-text">steck 4</div>
        </div>
        <div class="website-card">
            <div class="card-header"><div class="window-dots"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span></div></div>
            <div class="card-body"><img class="card-image" src="img/goii.png" alt="Abstract design 5"></div>
            <div class="card-footer-text">steck 5</div>
        </div>
    </div>

    <script>
        // --- [추가] 스파클 배경 애니메이션 스크립트 ---
        const canvas = document.getElementById('sparkle-canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        let particles = [];
        const numParticles = 800; // [수정] 파티클 수량을 800개로 증가
        // [수정] 더 밝은 파스텔 톤과 흰색을 추가하여 빛나는 느낌 강화
        const particleColors = ['#FFFFFF', '#E0F7FA', '#D1C4E9', '#BBDEFB', '#A7C7E7'];
        const mouse = {
            x: undefined,
            y: undefined,
            radius: 100 // 마우스 상호작용 반경
        };

        // 파티클(Particle) 클래스 정의
        class Particle {
            constructor() {
                // [수정] 파티클의 기준 위치를 저장
                this.baseX = Math.random() * width;
                this.baseY = Math.random() * height;
                this.x = this.baseX;
                this.y = this.baseY;
                // [수정] 크기를 더 작고 다양하게 조절 (0.2px ~ 2.7px)
                this.size = Math.random() * 2.5 + 0.2;
                // [수정] 파티클의 현재 속도
                this.speedX = 0;
                this.speedY = 0;
                // [수정] 지정된 푸른색 중에서 무작위로 색상 선택
                this.color = particleColors[Math.floor(Math.random() * particleColors.length)];
                // [추가] 파티클의 밀도 (움직임에 영향)
                this.density = (Math.random() * 30) + 1;
                // [추가] 파티클의 빛 효과를 위한 속성
                this.baseShadowBlur = Math.random() * 5 + 2; // 기본 빛의 세기
                this.shadowBlur = this.baseShadowBlur;
            }

            update() {
                // --- [수정] 마우스 반발 효과 로직 ---
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const forceDirectionX = dx / distance;
                const forceDirectionY = dy / distance;
                const maxDistance = mouse.radius;
                // 마우스와 가까울수록 힘이 강해짐
                const force = (maxDistance - distance) / maxDistance;

                let targetShadowBlur = this.baseShadowBlur;

                // 마우스 반경 내에 있으면 밀어내는 힘과 빛 효과 적용
                if (distance < mouse.radius) {
                    this.speedX -= forceDirectionX * force * 0.1 * this.density;
                    this.speedY -= forceDirectionY * force * 0.1 * this.density;

                    // [추가] 마우스가 가까울수록 빛이 강해짐
                    const proximity = 1 - (distance / mouse.radius);
                    targetShadowBlur = this.baseShadowBlur + proximity * 15;
                }
                // [추가] 빛의 세기를 부드럽게 변경
                this.shadowBlur += (targetShadowBlur - this.shadowBlur) * 0.1;

                // --- [추가] 원래 위치로 돌아가려는 힘과 감속 로직 ---
                // 원래 위치로 천천히 돌아가려는 힘
                this.speedX += (this.baseX - this.x) * 0.01;
                this.speedY += (this.baseY - this.y) * 0.01;

                // 속도에 감속(damping)을 적용하여 부드럽게 멈추도록 함
                this.speedX *= 0.95;
                this.speedY *= 0.95;

                this.x += this.speedX;
                this.y += this.speedY;
            }

            draw() {
                ctx.save(); // 현재 컨텍스트 설정을 저장
                // [추가] 파티클에 빛나는 효과(그림자) 적용
                ctx.shadowColor = 'white';
                ctx.shadowBlur = this.shadowBlur;
                ctx.fillStyle = this.color;
                // [수정] 최소 투명도를 높여 더 밝게 보이도록 수정
                ctx.globalAlpha = Math.random() * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); // 저장했던 컨텍스트 설정으로 복원 (다른 요소에 영향 방지)
            }
        }

        function handleParticles() {
            for (const particle of particles) {
                particle.update();
                particle.draw();
            }
        }

        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        document.addEventListener('DOMContentLoaded', () => {
            
            // --- [통합] 메뉴 바 애니메이션 스크립트 ---
            const slideDuration = 600;
            const welcomeWords = ['WELCOME', '안녕하세요', 'WELCOME', '환영합니다'];
            const projectWords = ['PROJECT', 'WORK', 'PROJECT', 'PRODUCT'];
            const contactWords = ['CONTACT', 'CALLME', 'CONTACT', 'TOUCH'];

            function setupHoverAnimation(elementId, words) {
                const menuItem = document.getElementById(elementId);
                if (!menuItem) return;
                const shifter = menuItem.querySelector('.word-shifter');
                const visibleWord = menuItem.querySelector('.visible-word');
                const hiddenWord = menuItem.querySelector('.hidden-word');
                let currentIndex = 0;
                let isAnimating = false;
                hiddenWord.textContent = words[(currentIndex + 1) % words.length];

                menuItem.addEventListener('mouseenter', () => {
                    if (isAnimating) return;
                    isAnimating = true;
                    menuItem.classList.add('is-animating');
                    setTimeout(() => {
                        currentIndex = (currentIndex + 1) % words.length;
                        shifter.style.transition = 'none';
                        visibleWord.textContent = words[currentIndex];
                        menuItem.classList.remove('is-animating');
                        hiddenWord.textContent = words[(currentIndex + 1) % words.length];
                        setTimeout(() => {
                            shifter.style.transition = '';
                            isAnimating = false;
                        }, 50);
                    }, slideDuration);
                });
            }
            setupHoverAnimation('menu-welcome', welcomeWords);
            setupHoverAnimation('menu-project', projectWords);
            setupHoverAnimation('menu-contact', contactWords);


            // --- 기존 쇼케이스 애니메이션 스크립트 ---
            const cards = Array.from(document.querySelectorAll('.website-card'));
            let order = Array.from({ length: cards.length }, (_, i) => i);
            let cardAnimating = false; // 변수명 충돌 방지: isAnimating -> cardAnimating
            const AUTO_SWAP_INTERVAL = 4000;
            const stackContainer = document.querySelector('.website-stack-container');
            let fanScrollOffset = 0; // [추가] 펼쳐진 상태에서의 스크롤 위치
            let centerCardStackIndex = 0; // [추가] 스냅 스크롤을 위한 중앙 카드 인덱스
            let isSnapping = false; // [추가] 스냅 스크롤 애니메이션 중복 방지 플래그
            
            // --- [추가] 카드별 텍스트 데이터 및 왼쪽 텍스트 영역 DOM ---    
            const showcaseTextContainer = document.querySelector('.showcase-text');
            const showcaseTitle = showcaseTextContainer.querySelector('h1');
            const showcaseDescription = showcaseTextContainer.querySelector('p');

            const defaultContent = {
                title: '“  To be Product designer ”',
                description: "저는 '낯섦'으로 시선을 끌고, '어울림'으로 마음을 붙잡습니다. \n\n혁신은 언제나 낯설지만, 그 경험은 반드시 직관적이어야 합니다. \n\n모두가 새로움을 만나는 어떠한 접점에서든 망설임 없이 다음 단계로 나아갈 수 있도록 어울리게, 그 모든 과정을 치밀하게 설계합니다. 가장 대담한 시도가 가장 편안한 경험이 되도록 하는 디자이너가 되도록, 끊임없이 노력하겠습니다."
            };
            const cardContentData = [
                { 
                    title: '“ To be Product designer ”', 
                    description: "skill | @illustrator @photoshop @indesign @Figma @vs code @midjourney @firefly ",
                    // [수정] 2번 카드와 동일한 구조로 링크 임시 설정
                    link: 'https://www.figma.com/slides/CH9U2wVKRSigzJ303VNpbN/2401110073-%EA%B9%80%ED%98%9C%EB%AF%BC_%EC%9C%84%ED%95%98%EB%8B%A4-%EA%B8%80%EB%A1%9C%EB%B2%8C?node-id=1-722&t=rYNHnV1JaE5ox8in-1'
                },
                { 
                    title: 'Dict Box Redesign', 
                    description: '한영사전 앱 Dict Box의 사용성을 개선하는 UI/UX 리디자인 프로젝트입니다. ctrl + click 을 통해 프로토타입을 보실 수 있습니다.' ,
                    link: 'https://www.figma.com/design/ZbC1LqGB8ldQxjZmH6sV8F/UI-dict-box?node-id=89-2&t=zc1f7NpLa1JNCKSP-1' // [추가] 2번 카드에 연결할 링크 (임시)
                },
                { title: 'Digital Graphic poster', description: '제품 누끼 촬영을 통해 이미지를 합성하고 편집합니다. 생성형 AI인 Firefly 를 도입해 컨셉과 어울리도록 작업되었습니다.' },
                { title: 'Steck 4: Advanced Integration', description: 'Details about advanced API integrations and backend services for the fourth stack.' },
                { 
                    title: 'Steck 5: Final Deployment', 
                    description: 'The final phase, covering deployment, testing, and launch strategies for the fifth project.',
                    link: 'https://www.figma.com/design/13lPq9mXFLFzG8wYnifspS/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9--4%EC%A1%B0?node-id=0-1&t=unEUJLhNDNWddlU4-1' // [추가] 5번 카드에 연결할 링크
                }
            ];

            function updateCardPositions(immediate = false) {
                order.forEach((cardIndex, stackPosition) => {
                    const card = cards[cardIndex];
                    if (!card) return;
                    const isVisible = stackPosition < 5; /* 5개 보이도록 수정 */
                    const opacity = Math.max(0, 1 - stackPosition * 0.15); // 뒤로 갈수록 흐려지게 계산
                    const scale = 1 - stackPosition * 0.15;
                    const y = -stackPosition * 80; /* 카드 간격 넓게 수정 */
                    const z = -stackPosition * 120;
                    card.style.transform = `translate3d(0px, ${y}px, ${z}px) scale(${scale})`;
                    card.style.zIndex = cards.length - stackPosition;
                    card.style.opacity = isVisible ? '1' : '0';
                    card.style.opacity = opacity;
                    if (immediate) {
                        card.style.transition = 'none';
                    } else {
                        card.style.transition = `transform var(--animation-duration) var(--animation-ease), opacity calc(var(--animation-duration) / 2) ease`;
                    }
                });

                if (immediate) {
                    void cards[0].offsetHeight;
                    cards.forEach(card => {
                        card.style.transition = `transform var(--animation-duration) var(--animation-ease), opacity calc(var(--animation-duration) / 2) ease`;
                    });
                }
            }

            // --- [추가] 스크롤 다운 애니메이션 (기존 swapAnimation과 유사) ---
            function scrollDown() {
                if (cardAnimating) return;
                cardAnimating = true;

                const frontCardIndex = order[0];
                const frontCard = cards[frontCardIndex];
                // 맨 위 카드를 아래로 사라지게 하는 애니메이션
                frontCard.style.transform = `translate3d(0, 150%, -200px) rotate(10deg)`;
                frontCard.style.opacity = '0';
                
                // order 배열 업데이트: 맨 앞 요소를 맨 뒤로
                order.push(order.shift());

                // 잠시 후 카드 위치를 즉시 재설정하고 애니메이션 활성화
                setTimeout(() => {
                    updateCardPositions();
                    setTimeout(() => cardAnimating = false, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-duration')) * 500);
                }, 200);
            }

            // --- [추가] 스크롤 업 애니메이션 ---
            function scrollUp() {
                if (cardAnimating) return;
                cardAnimating = true;

                // order 배열 업데이트: 맨 뒤 요소를 맨 앞으로
                order.unshift(order.pop());

                // 새롭게 맨 위가 된 카드를 초기 위치(위쪽)로 즉시 이동
                const newFrontCard = cards[order[0]];
                newFrontCard.style.transition = 'none';
                newFrontCard.style.transform = `translate3d(0, -150%, -200px) rotate(-10deg)`;
                newFrontCard.style.opacity = '0';

                // 잠시 후, 모든 카드의 위치를 애니메이션과 함께 업데이트
                setTimeout(() => {
                    updateCardPositions();
                    setTimeout(() => {
                        cardAnimating = false;
                    }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-duration')) * 500);
                }, 50);
            }

            // --- [추가] 카드를 펼치는 애니메이션을 별도 함수로 분리 ---
            function applyFanAnimation() {
                order.forEach((cardIndex, stackPosition) => {
                    const card = cards[cardIndex];
                    if (!card) return;

                    const totalCards = order.length;
                    const middleIndex = Math.floor(totalCards / 2);
                    const positionFromMiddle = stackPosition - middleIndex;

                    const translateX = 35; // [수정] 펼쳤을 때 오른쪽으로 덜 밀리도록 값 조정 (60 -> 35)
                    const rotateY = -45;
                    
                    // 기본 Y 위치 + 스크롤 오프셋
                    const baseTranslateY = positionFromMiddle * 115;
                    const finalTranslateY = baseTranslateY + fanScrollOffset;
                    
                    const transformValue = `translateX(${translateX}%) translateY(${finalTranslateY}%) rotateY(${rotateY}deg)`;

                    card.style.transitionDelay = `${stackPosition * 0.05}s`;
                    card.style.transform = transformValue;
                    card.style.opacity = '1';
                });
            }

            // --- [추가] 중앙에 온 카드를 기준으로 텍스트를 업데이트하는 함수 ---
            function updateTextToCenterCard() {
                let centerCardIndex = -1;
                let minDistance = Infinity;
                let centerCardElement = null;

                order.forEach((cardIndex, stackPosition) => {
                    const card = cards[cardIndex];
                    if (!card) return;
                    
                    // 카드의 현재 Y 위치를 가져옵니다.
                    const transformMatrix = new DOMMatrix(getComputedStyle(card).transform);
                    const currentY = transformMatrix.m42;
                    
                    // 화면 중앙(0)과의 거리를 계산합니다.
                    if (Math.abs(currentY) < minDistance) {
                        minDistance = Math.abs(currentY);
                        centerCardIndex = cardIndex;
                        centerCardElement = card;
                    }
                });

                // [수정] 텍스트 업데이트 및 중앙 카드 클래스 관리
                if (centerCardIndex !== -1 && cardContentData[centerCardIndex]) {
                    showcaseTitle.textContent = cardContentData[centerCardIndex].title;
                    showcaseDescription.textContent = cardContentData[centerCardIndex].description;

                    // 모든 카드에서 is-center 클래스 제거
                    cards.forEach(card => card.classList.remove('is-center'));
                    // 중앙 카드에만 is-center 클래스 추가
                    if (centerCardElement) {
                        centerCardElement.classList.add('is-center');
                    }
                }
            }


            // --- [수정] 클릭 시 부채꼴 애니메이션 로직 ---
            stackContainer.addEventListener('click', (e) => {
                const clickedCard = e.target.closest('.website-card');
                const isFanned = stackContainer.classList.contains('is-fanned');
                const focusedCard = document.querySelector('.website-card.is-focused');

                // --- [추가] Ctrl+Click 또는 Cmd+Click 이벤트 처리 ---
                // [수정] 카드가 펼쳐진 상태(is-fanned)에서 Ctrl/Cmd 키를 누르고 클릭하면 링크 열기
                if (isFanned && clickedCard && (e.ctrlKey || e.metaKey)) {
                    const cardIndex = cards.indexOf(clickedCard);
                    // 링크가 있는 카드인지 확인
                    if (cardIndex !== -1 && cardContentData[cardIndex] && cardContentData[cardIndex].link) {
                        window.open(cardContentData[cardIndex].link, '_blank'); // 새 탭에서 링크 열기
                        e.preventDefault(); // 기본 동작 방지
                        return; // 다른 클릭 로직 실행 중단
                    }
                }

                // 1. 펼쳐진 상태에서
                if (isFanned) {
                    // 1-1. 포커스된 카드가 있는데, 그 카드나 배경을 클릭하면 포커스 해제
                    if (focusedCard) {
                        focusedCard.classList.remove('is-focused');
                        stackContainer.classList.remove('has-focused');
                        // 만약 포커스된 카드 자체를 다시 클릭했다면, 스택이 닫히지 않도록 여기서 종료
                        if (clickedCard === focusedCard) return;
                    }

                    // 1-2. 특정 카드를 클릭하면 해당 카드 포커스
                    if (clickedCard) {
                        clickedCard.classList.add('is-focused');
                        stackContainer.classList.add('has-focused');
                        return; // 스택이 닫히지 않도록 여기서 종료
                    }
                }

                // 2. 스택을 열거나 닫는 기본 토글 로직
                // (펼쳐지지 않았을 때, 또는 펼쳐진 상태에서 배경을 클릭했을 때 실행)
                const shouldBeFanned = stackContainer.classList.toggle('is-fanned');

                if (shouldBeFanned) {
                    fanScrollOffset = 0; // 펼칠 때 스크롤 위치 초기화
                    centerCardStackIndex = Math.floor(cards.length / 2); // 중앙 카드로 인덱스 초기화
                    applyFanAnimation();
                    setTimeout(updateTextToCenterCard, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--animation-duration')) * 1000);
                } else {
                    cards.forEach(card => card.style.transitionDelay = '0s');
                    showcaseTitle.textContent = defaultContent.title;
                    showcaseDescription.textContent = defaultContent.description;
                    cards.forEach(card => card.classList.remove('is-center'));
                    updateCardPositions();
                }
            });

            // --- [추가] 카드 호버 시 텍스트 변경 이벤트 리스너 ---
            cards.forEach((card, index) => {
                card.addEventListener('mouseenter', () => {
                    // 카드가 펼쳐진 상태일 때만 텍스트를 변경
                    if (stackContainer.classList.contains('is-fanned')) {
                        const data = cardContentData[index];
                        if (data) {
                            showcaseTitle.textContent = data.title;
                            showcaseDescription.textContent = data.description;
                        }
                    }
                });
                card.addEventListener('mouseleave', () => {
                    // [수정] 마우스가 벗어났을 때 기본값으로 바로 돌아가지 않고,
                    // 중앙에 위치한 카드의 텍스트가 유지되도록 아래 로직을 제거합니다.
                    // updateTextToCenterCard(); // 혹은 중앙 카드로 텍스트를 되돌릴 수 있습니다.
                });
            });
            
            // --- [추가] 마우스 휠 이벤트 리스너 ---
            stackContainer.addEventListener('wheel', (e) => {
                // [수정] 카드가 펼쳐져 있고, 포커스된 카드가 없을 때만 스크롤 허용
                if (!stackContainer.classList.contains('is-fanned') || stackContainer.classList.contains('has-focused')) {
                    return;
                }

                e.preventDefault(); // 페이지 전체 스크롤 방지

                // --- [수정] 부드러운 스크롤을 위해 스냅 로직을 연속 스크롤로 변경 ---
                fanScrollOffset -= e.deltaY * 0.7; // 스크롤 감도 조절

                // 스크롤 범위 제한
                const cardGap = 115;
                const maxScroll = (Math.floor(cards.length / 2)) * cardGap;
                const minScroll = -(cards.length - 1 - Math.floor(cards.length / 2)) * cardGap;
                fanScrollOffset = Math.max(minScroll, Math.min(maxScroll, fanScrollOffset));

                applyFanAnimation();
                updateTextToCenterCard();
                /*
                if (e.deltaY < 0) {
                    // 휠 위로: 이전 카드로
                    centerCardStackIndex = Math.max(0, centerCardStackIndex - 1);
                } else {
                    // 휠 아래로: 다음 카드로
                    centerCardStackIndex = Math.min(cards.length - 1, centerCardStackIndex + 1);
                }

                isSnapping = true;

                // 목표 카드가 중앙에 오도록 fanScrollOffset 계산
                const middleIndex = Math.floor(cards.length / 2);
                const positionFromMiddle = centerCardStackIndex - middleIndex;
                fanScrollOffset = -positionFromMiddle * 115;

                // 애니메이션으로 위치 업데이트
                applyFanAnimation();
                updateTextToCenterCard();

                // 애니메이션 지속 시간 후 스냅 상태 해제
                setTimeout(() => {
                    isSnapping = false;
                }, 400); // 스냅 간의 최소 간격
                */
            });

            // --- [추가] ESC 키로 상세 보기 닫기 ---
            document.addEventListener('keydown', (e) => {
                // 'Escape' 키를 눌렀을 때
                if (e.key === 'Escape') {
                    const focusedCard = document.querySelector('.website-card.is-focused');
                    // 포커스된 카드가 있다면 포커스 해제
                    if (focusedCard) {
                        focusedCard.classList.remove('is-focused');
                        stackContainer.classList.remove('has-focused');
                    }
                }
            });

            updateCardPositions(true);

            // --- [추가] 파티클 초기 생성 ---
            function initParticles() {
                for (let i = 0; i < numParticles; i++) {
                    particles.push(new Particle());
                }
            }

            // --- [추가] 스파클 애니메이션 루프 시작 ---
            function animateParticles() {
                // [수정] 잔상 효과를 제거하기 위해 매 프레임 캔버스를 깨끗하게 지웁니다.
                ctx.clearRect(0, 0, width, height);
                handleParticles();
                requestAnimationFrame(animateParticles);
            }
            initParticles();
            animateParticles();
        });
    </script>
</body>
</html>